(require str split)
(require str split-lines)
(require str to-number)

(def! first (fn* (l) (nth l 0)))
(def! and (fn* (a b) (if (false? a) false b)))
(def! or (fn* (a b) (if (true? a) true b)))
(def! abs (fn* (n) (if (>= n 0) n (* n -1))))

(def! zip-list (fn* (l r)
    (if (or (empty? l) (empty? r))
        (list)
        (cons (list (first l) (first r)) (zip-list (rest l) (rest r))))))

(def! for-all (fn* (c l)
    (if (empty? l)
        true
        (and (c (first l)) (for-all c (rest l))))))

(def! filter (fn* (c l)
    (if (empty? l)
        l
        (if (c (first l))
            (cons (first l) (filter c (rest l)))
            (filter c (rest l))))))

(def! split-numbers (fn* (s) (map to-number (split s "\\s"))))

(def! parse (fn* (file) 
    (let* (input (slurp file)) (map split-numbers (split-lines input)))))

(def! sliding (fn* (l) (zip-list l (rest l))))

(def! diff (fn* (l) (- (nth l 0) (nth l 1))))

(def! list-diff (fn* (l) (map diff l)))

(def! less-3 (fn* (i) (<= (abs i) 3)))
(def! positive? (fn* (i) (> i 0)))
(def! negative? (fn* (i) (< i 0)))

(def! is-safe (fn* (l) 
    (and (for-all less-3 l) 
        (or (for-all positive? l) (for-all negative? l)))))

(def! input (parse "input/day2-test.txt"))
;(def! input (parse "input/day2.txt"))

;day2 part1
(println (count (filter is-safe (map list-diff (map sliding input)))))